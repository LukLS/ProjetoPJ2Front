{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useEnhancedEffect as useEnhancedEffect, unstable_useEventCallback as useEventCallback } from '@mui/utils';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useResizeObserver } from '@mui/x-internals/useResizeObserver';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridPrivateApiContext } from '../../utils/useGridPrivateApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { useRunOnce } from '../../utils/useRunOnce';\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from '../columns/gridColumnsSelector';\nimport { gridDimensionsSelector } from '../dimensions/gridDimensionsSelectors';\nimport { gridPinnedRowsSelector } from '../rows/gridRowsSelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridVisibleRows, getVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils';\nimport { clamp, range } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../rowSelection/gridRowSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils';\nimport { getMinimalContentHeight } from '../rows/gridRowsUtils';\nimport { gridRenderContextSelector, gridVirtualizationEnabledSelector, gridVirtualizationColumnEnabledSelector } from './gridVirtualizationSelectors';\nimport { EMPTY_RENDER_CONTEXT } from './useGridVirtualization';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (mode, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(mode, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nlet isJSDOM = false;\ntry {\n  if (typeof window !== 'undefined') {\n    isJSDOM = /jsdom/.test(window.navigator.userAgent);\n  }\n} catch (_) {\n  /* ignore */\n}\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const enabled = useGridSelector(apiRef, gridVirtualizationEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);\n  const outerSize = dimensions.viewportOuterSize;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const theme = useTheme();\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const gridRootRef = apiRef.current.rootElementRef;\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = React.useRef(null);\n  const scrollbarHorizontalRef = React.useRef(null);\n  const contentHeight = dimensions.contentSize.height;\n  const columnsTotalWidth = dimensions.columnsTotalWidth;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  useResizeObserver(mainRef, () => apiRef.current.resize());\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(theme.direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const focusedCell = {\n    rowIndex: React.useMemo(() => cellFocus ? currentPage.rows.findIndex(row => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),\n    columnIndex: React.useMemo(() => cellFocus ? visibleColumns.findIndex(column => column.field === cellFocus.field) : -1, [cellFocus, visibleColumns])\n  };\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if the dimensions are also available.\n    // So we wait until we have valid dimensions before publishing the first event.\n    if (dimensions.isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef, dimensions.isReady]);\n  const triggerUpdateRenderContext = () => {\n    const newScroll = {\n      top: scrollerRef.current.scrollTop,\n      left: scrollerRef.current.scrollLeft\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(theme.direction, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  };\n  const forceUpdateRenderContext = () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (scrollTop < 0) {\n      return;\n    }\n    if (theme.direction === 'ltr') {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (theme.direction === 'rtl') {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = function () {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const baseRenderContext = params.renderContext ?? renderContext;\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedCell.rowIndex !== -1) {\n      if (focusedCell.rowIndex < firstRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.unshift(virtualRowIndex);\n      }\n      if (focusedCell.rowIndex >= lastRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.push(virtualRowIndex);\n      }\n    }\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const hasFocus = cellFocus?.id === id;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = rowIndexInPage === rowModels.length - 1;\n        }\n      }\n      const isVirtualRow = rowIndexInPage === virtualRowIndex;\n      const isNotVisible = isVirtualRow;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      let currentRenderContext = baseRenderContext;\n      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, theme.direction, pinnedColumns.left.length);\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n      rows.push( /*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetTop: params.rows ? undefined : rowsMeta.positions[rowIndexInPage],\n        offsetLeft: offsetLeft,\n        dimensions: dimensions,\n        rowHeight: baseRowHeight,\n        tabbableCell: tabbableCell,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        renderContext: currentRenderContext,\n        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isNotVisible\n      }, rowProps), id));\n      if (isNotVisible) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (isLastVisible) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth >= outerSize.width;\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height: contentHeight\n    };\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = getMinimalContentHeight(apiRef); // Give room to show the overlay when there no rows.\n    }\n\n    return size;\n  }, [apiRef, columnsTotalWidth, contentHeight, needsHorizontalScrollbar, rootProps.autoHeight, currentPage.rows.length]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  useEnhancedEffect(() => {\n    // FIXME: Is this really necessary?\n    apiRef.current.resize();\n  }, [apiRef, rowsMeta.currentPageTotalHeight]);\n  useEnhancedEffect(() => {\n    if (enabled) {\n      // TODO a scroll reset should not be necessary\n      scrollerRef.current.scrollLeft = 0;\n      scrollerRef.current.scrollTop = 0;\n    }\n  }, [enabled, gridRootRef, scrollerRef]);\n  useRunOnce(outerSize.width !== 0, () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(initialRenderContext);\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: initialRenderContext\n    });\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridApiEventHandler(apiRef, 'columnsChange', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRef\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      tabIndex: -1,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation'\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      role: 'presentation'\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      role: 'presentation'\n    })\n  };\n};\nfunction inputsSelector(apiRef, rootProps, enabled, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabled,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef.current.state),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  let renderContext;\n  if (!inputs.enabled) {\n    renderContext = {\n      firstRowIndex: 0,\n      lastRowIndex: inputs.rows.length,\n      firstColumnIndex: 0,\n      lastColumnIndex: inputs.visibleColumns.length\n    };\n  } else {\n    const {\n      top,\n      left\n    } = scrollPosition;\n    const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    const firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    if (inputs.enabledForColumns) {\n      let hasRowWithAutoHeight = false;\n      const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n        firstIndex: firstRowIndex,\n        lastIndex: lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: inputs.rows.length,\n        bufferBefore: scrollCache.buffer.rowBefore,\n        bufferAfter: scrollCache.buffer.rowAfter,\n        positions: inputs.rowsMeta.positions,\n        lastSize: inputs.lastRowHeight\n      });\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n      if (!hasRowWithAutoHeight) {\n        firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n          atStart: true,\n          lastPosition: inputs.columnsTotalWidth\n        });\n        lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n      }\n    }\n    renderContext = {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let sliceStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let sliceEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : positions.length;\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender(_ref) {\n  let {\n    firstIndex,\n    lastIndex,\n    bufferBefore,\n    bufferAfter,\n    minFirstIndex,\n    maxLastIndex,\n    positions,\n    lastSize\n  } = _ref;\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, direction, pinnedLeftLength) {\n  const factor = direction === 'ltr' ? 1 : -1;\n  const left = factor * (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\n\nfunction bufferForDirection(mode, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (mode === 'rtl') {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}","map":{"version":3,"names":["_extends","React","ReactDOM","unstable_useEnhancedEffect","useEnhancedEffect","unstable_useEventCallback","useEventCallback","useLazyRef","useTimeout","useResizeObserver","useTheme","useGridPrivateApiContext","useGridRootProps","useGridSelector","useRunOnce","gridVisibleColumnDefinitionsSelector","gridVisiblePinnedColumnDefinitionsSelector","gridColumnPositionsSelector","gridHasColSpanSelector","gridDimensionsSelector","gridPinnedRowsSelector","gridFocusCellSelector","gridTabIndexCellSelector","useGridVisibleRows","getVisibleRows","useGridApiEventHandler","clamp","range","selectedIdsLookupSelector","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","getMinimalContentHeight","gridRenderContextSelector","gridVirtualizationEnabledSelector","gridVirtualizationColumnEnabledSelector","EMPTY_RENDER_CONTEXT","jsx","_jsx","MINIMUM_COLUMN_WIDTH","ScrollDirection","EMPTY_SCROLL_POSITION","top","left","EMPTY_DETAIL_PANELS","Object","freeze","Map","createScrollCache","mode","rowBufferPx","columnBufferPx","verticalBuffer","horizontalBuffer","direction","NONE","buffer","bufferForDirection","isJSDOM","window","test","navigator","userAgent","_","useGridVirtualScroller","apiRef","rootProps","visibleColumns","enabled","enabledForColumns","dimensions","outerSize","viewportOuterSize","pinnedRows","pinnedColumns","hasBottomPinnedRows","bottom","length","panels","setPanels","useState","theme","cellFocus","cellTabIndex","rowsMeta","selectedRowsLookup","currentPage","gridRootRef","current","rootElementRef","mainRef","mainElementRef","scrollerRef","virtualScrollerRef","scrollbarVerticalRef","useRef","scrollbarHorizontalRef","contentHeight","contentSize","height","columnsTotalWidth","hasColSpan","resize","scrollPosition","previousContextScrollPosition","previousRowContext","renderContext","scrollTimeout","frozenContext","undefined","scrollCache","rowHeight","focusedCell","rowIndex","useMemo","rows","findIndex","row","id","columnIndex","column","field","updateRenderContext","useCallback","nextRenderContext","areRenderContextsEqual","state","virtualization","didRowsIntervalChange","firstRowIndex","lastRowIndex","setState","isReady","publishEvent","triggerUpdateRenderContext","newScroll","scrollTop","scrollLeft","dx","dy","isScrolling","directionForDelta","rowScroll","Math","abs","columnScroll","didCrossThreshold","didChangeDirection","shouldUpdate","LEFT","RIGHT","inputs","inputsSelector","computeRenderContext","flushSync","start","forceUpdateRenderContext","handleScroll","event","currentTarget","handleWheel","handleTouchMove","getRows","params","arguments","baseRenderContext","isLastSection","position","isPinnedSection","rowIndexOffset","rowModels","firstRowToRender","lastRowToRender","min","rowIndexes","virtualRowIndex","unshift","push","rowProps","slotProps","columnPositions","forEach","rowIndexInPage","model","minFirstColumn","maxLastColumn","right","calculateColSpan","rowId","columns","hasFocus","baseRowHeight","rowHasAutoHeight","unstable_getRowHeight","isSelected","isRowSelectable","isFirstVisible","isLastVisible","lastIndex","isLastVisibleRowIndex","isVirtualRow","isNotVisible","tabbableCell","cellParams","getCellParams","cellMode","currentRenderContext","offsetLeft","computeOffsetLeft","slots","index","selected","offsetTop","positions","focusedColumnIndex","panel","get","getInfiniteLoadingTriggerElement","lastRowId","needsHorizontalScrollbar","width","scrollerStyle","overflowX","overflowY","autoHeight","size","useEffect","currentPageTotalHeight","initialRenderContext","register","getContainerProps","ref","getScrollerProps","tabIndex","onScroll","onWheel","onTouchMove","style","role","getContentProps","getRenderZoneProps","getScrollbarVerticalProps","getScrollbarHorizontalProps","dataRowIds","at","lastColumn","leftPinnedWidth","viewportInnerWidth","viewportInnerSize","viewportInnerHeight","lastRowHeight","lastColumnWidth","computedWidth","firstColumnIndex","lastColumnIndex","realLeft","getNearestIndexToRender","atStart","lastPosition","hasRowWithAutoHeight","getIndexesToRender","firstIndex","minFirstIndex","maxLastIndex","bufferBefore","rowBefore","bufferAfter","rowAfter","lastSize","i","binarySearch","actualRenderContext","deriveRenderContext","offset","options","lastMeasuredIndexRelativeToAllRows","getLastMeasuredRowIndex","allRowsMeasured","Infinity","lastMeasuredIndexRelativeToCurrentPage","exponentialSearch","initialFirstColumnToRender","lastColumnToRender","columnBefore","columnAfter","firstColumnToRender","visibleRows","sliceStart","sliceEnd","pivot","floor","isBefore","interval","_ref","firstPosition","firstIndexPadded","lastIndexPadded","context1","context2","pinnedLeftLength","factor","DOWN","UP","Error"],"sources":["C:/Users/franc/Desktop/Projetos/ProjetoAdvocaciaFront/node_modules/@mui/x-data-grid/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { unstable_useEnhancedEffect as useEnhancedEffect, unstable_useEventCallback as useEventCallback } from '@mui/utils';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useResizeObserver } from '@mui/x-internals/useResizeObserver';\nimport { useTheme } from '@mui/material/styles';\nimport { useGridPrivateApiContext } from '../../utils/useGridPrivateApiContext';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { useRunOnce } from '../../utils/useRunOnce';\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from '../columns/gridColumnsSelector';\nimport { gridDimensionsSelector } from '../dimensions/gridDimensionsSelectors';\nimport { gridPinnedRowsSelector } from '../rows/gridRowsSelector';\nimport { gridFocusCellSelector, gridTabIndexCellSelector } from '../focus/gridFocusStateSelector';\nimport { useGridVisibleRows, getVisibleRows } from '../../utils/useGridVisibleRows';\nimport { useGridApiEventHandler } from '../../utils';\nimport { clamp, range } from '../../../utils/utils';\nimport { selectedIdsLookupSelector } from '../rowSelection/gridRowSelectionSelector';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getFirstNonSpannedColumnToRender } from '../columns/gridColumnsUtils';\nimport { getMinimalContentHeight } from '../rows/gridRowsUtils';\nimport { gridRenderContextSelector, gridVirtualizationEnabledSelector, gridVirtualizationColumnEnabledSelector } from './gridVirtualizationSelectors';\nimport { EMPTY_RENDER_CONTEXT } from './useGridVirtualization';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (mode, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(mode, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nlet isJSDOM = false;\ntry {\n  if (typeof window !== 'undefined') {\n    isJSDOM = /jsdom/.test(window.navigator.userAgent);\n  }\n} catch (_) {\n  /* ignore */\n}\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const enabled = useGridSelector(apiRef, gridVirtualizationEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const dimensions = useGridSelector(apiRef, gridDimensionsSelector);\n  const outerSize = dimensions.viewportOuterSize;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumns = useGridSelector(apiRef, gridVisiblePinnedColumnDefinitionsSelector);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const theme = useTheme();\n  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);\n  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);\n  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);\n  const currentPage = useGridVisibleRows(apiRef, rootProps);\n  const gridRootRef = apiRef.current.rootElementRef;\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = React.useRef(null);\n  const scrollbarHorizontalRef = React.useRef(null);\n  const contentHeight = dimensions.contentSize.height;\n  const columnsTotalWidth = dimensions.columnsTotalWidth;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  useResizeObserver(mainRef, () => apiRef.current.resize());\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(theme.direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const focusedCell = {\n    rowIndex: React.useMemo(() => cellFocus ? currentPage.rows.findIndex(row => row.id === cellFocus.id) : -1, [cellFocus, currentPage.rows]),\n    columnIndex: React.useMemo(() => cellFocus ? visibleColumns.findIndex(column => column.field === cellFocus.field) : -1, [cellFocus, visibleColumns])\n  };\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if the dimensions are also available.\n    // So we wait until we have valid dimensions before publishing the first event.\n    if (dimensions.isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef, dimensions.isReady]);\n  const triggerUpdateRenderContext = () => {\n    const newScroll = {\n      top: scrollerRef.current.scrollTop,\n      left: scrollerRef.current.scrollLeft\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= dimensions.rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(theme.direction, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, dimensions.rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  };\n  const forceUpdateRenderContext = () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(event => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = event.currentTarget;\n\n    // On iOS and macOS, negative offsets are possible when swiping past the start\n    if (scrollTop < 0) {\n      return;\n    }\n    if (theme.direction === 'ltr') {\n      if (scrollLeft < 0) {\n        return;\n      }\n    }\n    if (theme.direction === 'rtl') {\n      if (scrollLeft > 0) {\n        return;\n      }\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollTop,\n      left: scrollLeft,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = (params = {}) => {\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const baseRenderContext = params.renderContext ?? renderContext;\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedCell.rowIndex !== -1) {\n      if (focusedCell.rowIndex < firstRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.unshift(virtualRowIndex);\n      }\n      if (focusedCell.rowIndex >= lastRowToRender) {\n        virtualRowIndex = focusedCell.rowIndex;\n        rowIndexes.push(virtualRowIndex);\n      }\n    }\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const hasFocus = cellFocus?.id === id;\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      let isSelected;\n      if (selectedRowsLookup[id] == null) {\n        isSelected = false;\n      } else {\n        isSelected = apiRef.current.isRowSelectable(id);\n      }\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = rowIndexInPage === rowModels.length - 1;\n        }\n      }\n      const isVirtualRow = rowIndexInPage === virtualRowIndex;\n      const isNotVisible = isVirtualRow;\n      let tabbableCell = null;\n      if (cellTabIndex !== null && cellTabIndex.id === id) {\n        const cellParams = apiRef.current.getCellParams(id, cellTabIndex.field);\n        tabbableCell = cellParams.cellMode === 'view' ? cellTabIndex.field : null;\n      }\n      let currentRenderContext = baseRenderContext;\n      if (!isPinnedSection && frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, theme.direction, pinnedColumns.left.length);\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n      rows.push( /*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetTop: params.rows ? undefined : rowsMeta.positions[rowIndexInPage],\n        offsetLeft: offsetLeft,\n        dimensions: dimensions,\n        rowHeight: baseRowHeight,\n        tabbableCell: tabbableCell,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        renderContext: currentRenderContext,\n        focusedColumnIndex: hasFocus ? focusedCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isNotVisible\n      }, rowProps), id));\n      if (isNotVisible) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (isLastVisible) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const needsHorizontalScrollbar = outerSize.width && columnsTotalWidth >= outerSize.width;\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      height: contentHeight\n    };\n    if (rootProps.autoHeight && currentPage.rows.length === 0) {\n      size.height = getMinimalContentHeight(apiRef); // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [apiRef, columnsTotalWidth, contentHeight, needsHorizontalScrollbar, rootProps.autoHeight, currentPage.rows.length]);\n  React.useEffect(() => {\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange');\n  }, [apiRef, contentSize]);\n  useEnhancedEffect(() => {\n    // FIXME: Is this really necessary?\n    apiRef.current.resize();\n  }, [apiRef, rowsMeta.currentPageTotalHeight]);\n  useEnhancedEffect(() => {\n    if (enabled) {\n      // TODO a scroll reset should not be necessary\n      scrollerRef.current.scrollLeft = 0;\n      scrollerRef.current.scrollTop = 0;\n    }\n  }, [enabled, gridRootRef, scrollerRef]);\n  useRunOnce(outerSize.width !== 0, () => {\n    const inputs = inputsSelector(apiRef, rootProps, enabled, enabledForColumns);\n    const initialRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    updateRenderContext(initialRenderContext);\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: initialRenderContext\n    });\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridApiEventHandler(apiRef, 'columnsChange', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', forceUpdateRenderContext);\n  useGridApiEventHandler(apiRef, 'rowExpansionChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRef\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      tabIndex: -1,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation'\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      role: 'presentation'\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      role: 'presentation'\n    })\n  };\n};\nfunction inputsSelector(apiRef, rootProps, enabled, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabled,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef.current.state),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  let renderContext;\n  if (!inputs.enabled) {\n    renderContext = {\n      firstRowIndex: 0,\n      lastRowIndex: inputs.rows.length,\n      firstColumnIndex: 0,\n      lastColumnIndex: inputs.visibleColumns.length\n    };\n  } else {\n    const {\n      top,\n      left\n    } = scrollPosition;\n    const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    const firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    if (inputs.enabledForColumns) {\n      let hasRowWithAutoHeight = false;\n      const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n        firstIndex: firstRowIndex,\n        lastIndex: lastRowIndex,\n        minFirstIndex: 0,\n        maxLastIndex: inputs.rows.length,\n        bufferBefore: scrollCache.buffer.rowBefore,\n        bufferAfter: scrollCache.buffer.rowAfter,\n        positions: inputs.rowsMeta.positions,\n        lastSize: inputs.lastRowHeight\n      });\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n      if (!hasRowWithAutoHeight) {\n        firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n          atStart: true,\n          lastPosition: inputs.columnsTotalWidth\n        });\n        lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n      }\n    }\n    renderContext = {\n      firstRowIndex,\n      lastRowIndex,\n      firstColumnIndex,\n      lastColumnIndex\n    };\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, direction, pinnedLeftLength) {\n  const factor = direction === 'ltr' ? 1 : -1;\n  const left = factor * (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(mode, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (mode === 'rtl') {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}